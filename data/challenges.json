[
  {
    "id": "calculate-optimal-dimensions",
    "project": "visual-fraction-library",
    "summary": "Optimizing Space in Two Dimensions",
    "challenge": "I needed to calculate how big each circle should be for images with mixed numbers that need to show up to 300 circles in an SVG with varying dimensions and width to height ratios. I wanted the circles to big as big as possible and be spaced evenly",
    "explanation": "Given a width and height of a container and a number of roughly-square items to fit inside of the container, this function returns the optimal size of each item so that they will all fit and use as much of the available space as possible. For example, given a width of 900 pixels and a height of 300 pixels, the aspect ratio would be 3 (900 / 300). If we wanted to fit say 100 items in a 900 by 300 container, multiplying 100 by the aspect ratio allows us to consider how to evenly distribute 300 (100*3) items within a 900 by 900 pixel square. This can easily be done by taking the square root of 300 (triple the number of items we actually need) to determine that we need a little over 17 items to go in each row. In order to avoid overflow in the horizontal direction, I used Math.floor() method which will force the items per row to be 17. Since we actually only need 100 items in a 900 by 300 pixel container, we can calculate the number of rows needed with 100 / 17. This results in 5.88 which really means we need 6 rows but the last row will not be filled, which is why I used Math.ceil(). Since our container has an aspect ratio of 900:300, simplified 3:1, the ratio of itemsPerRow : numRows should be as close as possible to this ratio, but the function will prioritize making sure all items fully fit inside. If you want the items to be spaced out, multiply the width and height parameters by a scale factor less than one.",
    "codeSnippet": "calculateOptimalDimensions.js",
    "example": "https://codepen.io/MathematiCode/pen/WNqvXod"
  },
  {
    "id": "number-of-colors-for-division",
    "project": "visual-fraction-library",
    "summary": "Avoid Matching Adjacent Groups for Division",
    "challenge": "For modelling Fraction Division with circles, I was splitting circles into groups based on the size of the divisor and using color to differentiate each group. For any number of colors that I chose, there was always going to be some divisors that resulted in two separate groups of the same color being adjacent to each other. This causes confusion because it looks like they are all part of the same group due to being the same color. So I needed to write an algorithm that takes in the divisor and outputs the ideal number of colors to use in that model to prevent this confusion.",
    "explanation": "This function uses recursion to find the ideal number of colors to show fraction division with circles and avoid two separate groups of the same color bordering each other (imagine 3 groups of 2/6ths in a circle and only 2 alternating colors. You would have 4/6ths all adjacent to each other in the same color which would be confusing and misleading. So the idealNumColors for any problem with a divisor of 2/6ths would be 3. But with divisors such as 4/7ths for example, not every circle will have the same number of groups. One circle may have 4/7ths and 3/7ths (minGroupsPerCircle = 2) but the next circle would then have 1/7th, 4/7ths, and 2/7ths (maxGroupsPerCircle = 3). This means the remainders of minGroupsPerCircle/numColors and maxGroupsPerCircle / numColors should not be 1. Take 5/9ths as an example.The minGroupsPerCircle is 2 (5/9ths and 4/9ths for example) and the maxGroupsPerCircle is 3 (1/9th, 5/9ths, and 3/9ths for example). First the function will try numColors = 2. For the circles with 3 different groups, there would be two adjacent groups with the same color which is a problem. The check for maxGroupsPerCircle % numColors === 1 will be true (indicating that numColors cannot be 2). Then the function calls itself to run again, this time trying numColors = 3. 3 alternating colors will work for both circles with two groups and three groups. So this function would return the idealNumColors as 3. The algorithm will sometimes choose more colors than needed but I prefer it that way.",
    "codeSnippet": "findIdealNumColors.js"
  },
  {
    "id": "too-many-params",
    "project": "visual-fraction-library",
    "summary": "Refactoring Too Many Parameters",
    "challenge": "",
    "explanation": "",
    "codeSnippet": ""
  },
  {
    "id": "state-across-contexts",
    "project": "frectangles",
    "summary": "Managing State Across Multiple Levels of Context",
    "challenge": "",
    "explanation": "",
    "codeSnippet": ""
  },
  {
    "id": "ux-piece-placements",
    "project": "frectangles",
    "summary": "Optimal UX for out of bounds piece placements",
    "challenge": "",
    "explanation": "",
    "codeSnippet": ""
  },
  {
    "id": "collision-detection",
    "project": "frectangles",
    "summary": "Custom Collision Detection Algorithm",
    "challenge": "Dnd Kit, the drag and drop library I was using assumed each draggable mapped to a single drop target, but my pieces spanned multiple grid cells. This was causing the pieces to occasionally drop into adjacent spaces instead of the correct space when they were placed near the edge.",
    "explanation": "I dug into the libraryâ€™s sparse documentation and source code, eventually writing a custom algorithm to determine valid drop positions based on the top-left corner of each piece. This made the drag and drop experience feel much more precise and predictable.",
    "codeSnippet": "export function rateDroppability(x: number, y: number, droppableRect: any) {\n  const { top, left, width, height } = droppableRect;\n  /* I'm multiplying the width and height by 2 to allow a greater range of droppableRects\n  to be considered by decreasing the likelihood of a negative xOffsetRatio or yOffsetRatio */\n  const xOffsetRatio = (width * 2 - Math.abs(x - left)) / (width * 2);\n  const yOffsetRatio = (height * 2 - Math.abs(y - top)) / (height * 2);\n  if (xOffsetRatio < 0 && yOffsetRatio < 0) return 0;\n  return (xOffsetRatio * yOffsetRatio).toFixed(3);\n}\n\nfunction customCollisionDetection(args: any) {\n  const { collisionRect } = args;\n\n  const x = collisionRect.left;\n  const y = collisionRect.top;\n\n  let potentialDroppables: any = rectIntersection(args);\n  if (potentialDroppables[0]) {\n    potentialDroppables.forEach((droppable: any) => {\n      const droppableRect = droppable.data.droppableContainer.rect.current;\n      droppable.data.value = rateDroppability(x, y, droppableRect);\n    });\n  }\n  return potentialDroppables.sort(compareCollisionRects);\n}"
  },
  {
    "id": "untangling-contexts",
    "project": "frectangles",
    "summary": "Untangling Contexts and Components",
    "challenge": "I have 5 different contexts each with their own functions that operate on that context, which is a nice pattern. But it got messy because I was calling a function to update one context inside of a function that's supposed to operate on its own context. So I had to make sure the functions in each context only make changes to their own context and to bring any other logic or function calls outside of the context file.",
    "explanation": "Basically if movePiece is a function that operates on PiecesInPlay (a context) I had it set up like this:",
    "codeSnippet": "movePiece(newLocation) {\n// math that checks if newLocation is valid\n// updates newLocation to a valid one\n// removePieceFromBoard (which updates a different context)\n// actually move the piece\n// addPieceToBoard (which updates a different context)\n}\n\nonDragEnd {\n// Maybe more logic that also can update the location (this made things very confusing)\nmovePiece(newLocation)\n}\n\nremovePieceFromBoard and addPieceToBoard are functions in a different context file that \n just keeps track of the 2D array representing the board. But they don't actually \n do anything visually.\n\nAnd I had to change it to\n\nmovePiece(newLocation) {\n// actually move the piece in the PiecesInPlay context (which makes it move visually)\n}\n\nonDragEnd {\n// math that checks if newLocation is valid\n// updates newLocation to a valid one\n// removePieceFromBoard (which updates a different context)\nmovePiece(newLocation)\n// addPieceToBoard (which updates a different context) \n}"
  },
  {
    "id": "testing-multi-user",
    "project": "secret-santa",
    "summary": "Testing Multi-User Interactions",
    "challenge": "",
    "explanation": "",
    "codeSnippet": ""
  },
  {
    "id": "loading-sequence",
    "project": "meet-near-me",
    "summary": "Dependency Loading Sequence for Embed Widget",
    "challenge": "",
    "explanation": "",
    "codeSnippet": ""
  },
  {
    "id": "location-UX",
    "project": "meet-near-me",
    "summary": "UX for setting location temporarily or permanantly",
    "challenge": "",
    "explanation": "",
    "codeSnippet": ""
  }
]
