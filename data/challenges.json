[
  {
    "id": "calculate-optimal-dimensions",
    "project": "visual-fraction-library",
    "summary": "Optimizing Space in Two Dimensions",
    "challenge": "I needed to calculate how big each circle should be for images with mixed numbers that need to show up to 300 circles in an SVG with varying dimensions and width to height ratios. I wanted the circles to big as big as possible and be spaced evenly",
    "explanation": "Given a width and height of a container and a number of roughly-square items to fit inside of the container, this function returns the optimal size of each item so that they will all fit and use as much of the available space as possible. For example, given a width of 900 pixels and a height of 300 pixels, the aspect ratio would be 3 (900 / 300). If we wanted to fit say 100 items in a 900 by 300 container, multiplying 100 by the aspect ratio allows us to consider how to evenly distribute 300 (100*3) items within a 900 by 900 pixel square. This can easily be done by taking the square root of 300 (triple the number of items we actually need) to determine that we need a little over 17 items to go in each row. In order to avoid overflow in the horizontal direction, I used Math.floor() method which will force the items per row to be 17. Since we actually only need 100 items in a 900 by 300 pixel container, we can calculate the number of rows needed with 100 / 17. This results in 5.88 which really means we need 6 rows but the last row will not be filled, which is why I used Math.ceil(). Since our container has an aspect ratio of 900:300, simplified 3:1, the ratio of itemsPerRow : numRows should be as close as possible to this ratio, but the function will prioritize making sure all items fully fit inside. If you want the items to be spaced out, multiply the width and height parameters by a scale factor less than one.",
    "codeSnippet": "calculateOptimalDimensions.js",
    "example": "https://codepen.io/MathematiCode/pen/WNqvXod"
  },
  {
    "id": "number-of-colors-for-division",
    "project": "visual-fraction-library",
    "summary": "Avoid Matching Adjacent Groups for Division",
    "challenge": "For modelling Fraction Division with circles, I was splitting circles into groups based on the size of the divisor and using color to differentiate each group. For any number of colors that I chose, there was always going to be some divisors that resulted in two separate groups of the same color being adjacent to each other. This causes confusion because it looks like they are all part of the same group due to being the same color. So I needed to write an algorithm that takes in the divisor and outputs the ideal number of colors to use in that model to prevent this confusion.",
    "explanation": "This function uses recursion to find the ideal number of colors to show fraction division with circles and avoid two separate groups of the same color bordering each other (imagine 3 groups of 2/6ths in a circle and only 2 alternating colors. You would have 4/6ths all adjacent to each other in the same color which would be confusing and misleading. So the idealNumColors for any problem with a divisor of 2/6ths would be 3. But with divisors such as 4/7ths for example, not every circle will have the same number of groups. One circle may have 4/7ths and 3/7ths (minGroupsPerCircle = 2) but the next circle would then have 1/7th, 4/7ths, and 2/7ths (maxGroupsPerCircle = 3). This means the remainders of minGroupsPerCircle/numColors and maxGroupsPerCircle / numColors should not be 1. Take 5/9ths as an example.The minGroupsPerCircle is 2 (5/9ths and 4/9ths for example) and the maxGroupsPerCircle is 3 (1/9th, 5/9ths, and 3/9ths for example). First the function will try numColors = 2. For the circles with 3 different groups, there would be two adjacent groups with the same color which is a problem. The check for maxGroupsPerCircle % numColors === 1 will be true (indicating that numColors cannot be 2). Then the function calls itself to run again, this time trying numColors = 3. 3 alternating colors will work for both circles with two groups and three groups. So this function would return the idealNumColors as 3. The algorithm will sometimes choose more colors than needed but I prefer it that way.",
    "codeSnippet": "findIdealNumColors.js"
  },
  {
    "id": "state-across-contexts",
    "project": "frectangles",
    "summary": "Managing State Across Multiple Levels of Context",
    "challenge": "I wanted to detect when the user had passed the level and I could do that with my BoardSquares context. This uses React Context to keep track of a 2 dimensional array representing each board square and which piece or pieces are currently located in each square. When they pass a level, I wanted to take my PiecesInPlay context (which resets every level) and save it as the solution for that level in GameProgress context. Since these are all separate contexts using React's Context API, I had to nest them so that PiecesInPlay is a child of BoardSquares. Technically these operate at the same level of abstraction and both update with each level change, but I had to make one a child of the other. I could have checked for a winning state within BoardSquares on each update but that would mean updating one context (GameProgress) inside of another (BoardSquares). And since PiecesInPlay is a child of BoardSquares, I wouldn't be able to access it from BoardSquares in order to save the players solution for that level.",
    "explanation": "One option was to combine the BoardSquaresContext and the PiecesInPlay context into one so I didn't have to deal with the nesting problem. But they were already pretty complex on their own, each with several methods. \n\n\n The challenge was checking for a winning state on each player move which could be done within the contexts where I was already handling each player move. But since this checking wasn't directly related to the responsibilities of PiecesInPlay or BoardSquares, I had to move this checking logic outside of both contexts. LLM's were pushing me to use useEffect but I knew it wasn't necessary for this case. Instead, I came up with a custom hook that returns a callback function that checks BoardSquares to see if it's in a winning state and if so saves the solution to GameProgress. I'm calling that callback on all user events that could result in winning.",
    "codeSnippet": "import { useBoardSquares } from '../context/BoardSquares';\nimport { useGameProgress } from '../context/GameProgress';\nimport { usePiecesInPlay } from '../context/PiecesInPlay';\nimport { useCurrentLevel } from '../context/CurrentLevel';\nimport { useCallback } from 'react';\n\nexport function useLevelStatus() {\n  const { getUnstablePieces, countEmptySquares } = useBoardSquares();\n  const { setLevelCompleted } = useGameProgress();\n  const { currentLevel } = useCurrentLevel();\n  const { piecesInPlay } = usePiecesInPlay();\n  const unstablePieces = getUnstablePieces();\n\n  const checkAndHandleLevelStatus = useCallback(() => {\n    const isLevelPassed =\n      unstablePieces.length === 0 && countEmptySquares() === 0;\n    if (isLevelPassed) {\n      setLevelCompleted(currentLevel, piecesInPlay);\n    }\n  }, [\n    unstablePieces,\n    countEmptySquares,\n    currentLevel,\n    piecesInPlay,\n    setLevelCompleted,\n  ]);\n\n  return { checkAndHandleLevelStatus };\n}"
  },
  {
    "id": "ux-piece-placements",
    "project": "frectangles",
    "summary": "Optimal UX for out of bounds piece placements",
    "challenge": "I needed a way to handle overlapping and out of bounds pieces. At this stage, it was possible to have a piece hidden under another piece and go completely unnoticed. At first I wanted to completely prevent pieces from overlapping by immediately shifting them into the closest valid location. Unfortunately, this was not always possible for pieces that were overlapping or out of bounds due to a mathematical transformation. For example, it's possible to make a piece wider than the whole game board. I felt having the pieces `sometimes` move into a valid spot and sometimes stay in an unvalid state would be a really confusing user experience. I considered disabling actions that caused the pieces to be longer or taller than the puzzle board but I realized this would take away an opportunity for players to make mistakes and learn from them. I considered transforming the piece into the unvalid state for a moment, and then transforming it back, but this still could remove the opportunity to think and learn from this. All transformations have an inverse so if a student accidentally doubled the width and halved the height of a piece and it ended up wider than the board, I wanted them to realize that they now have to halve the width and double the height, not undo it for them. Additionally, there are some cases where you'd want to temporarily transform a piece into an invalid state so you could apply a second transformation to get the pieces you want.",
    "explanation": "I decided to allow all piece overlaps and all valid and invalid transformations to maximize learning opportunities from making and fixing mistakes. I provided a clear affordance for overlapping and out of bounds by making the pieces vibrate to represent an unstable state.",
    "codeSnippet": ""
  },
  {
    "id": "collision-detection",
    "project": "frectangles",
    "summary": "Custom Collision Detection Algorithm",
    "challenge": "Dnd Kit, the drag and drop library I was using assumed each draggable mapped to a single drop target, but my pieces spanned multiple grid cells. This was causing the pieces to occasionally drop into adjacent spaces instead of the correct space when they were placed near the edge.",
    "explanation": "I dug into the libraryâ€™s sparse documentation and source code, eventually writing a custom algorithm to determine valid drop positions based on the top-left corner of each piece. This made the drag and drop experience feel much more precise and predictable.",
    "codeSnippet": "export function rateDroppability(x: number, y: number, droppableRect: any) {\n  const { top, left, width, height } = droppableRect;\n  /* I'm multiplying the width and height by 2 to allow a greater range of droppableRects\n  to be considered by decreasing the likelihood of a negative xOffsetRatio or yOffsetRatio */\n  const xOffsetRatio = (width * 2 - Math.abs(x - left)) / (width * 2);\n  const yOffsetRatio = (height * 2 - Math.abs(y - top)) / (height * 2);\n  if (xOffsetRatio < 0 && yOffsetRatio < 0) return 0;\n  return (xOffsetRatio * yOffsetRatio).toFixed(3);\n}\n\nfunction customCollisionDetection(args: any) {\n  const { collisionRect } = args;\n\n  const x = collisionRect.left;\n  const y = collisionRect.top;\n\n  let potentialDroppables: any = rectIntersection(args);\n  if (potentialDroppables[0]) {\n    potentialDroppables.forEach((droppable: any) => {\n      const droppableRect = droppable.data.droppableContainer.rect.current;\n      droppable.data.value = rateDroppability(x, y, droppableRect);\n    });\n  }\n  return potentialDroppables.sort(compareCollisionRects);\n}"
  },
  {
    "id": "untangling-contexts",
    "project": "frectangles",
    "summary": "Untangling Contexts and Components",
    "challenge": "I have 5 different contexts each with their own functions that operate on that context, which is a nice pattern. But it got messy because I was calling a function to update one context inside of a function that's supposed to operate on its own context. So I had to make sure the functions in each context only make changes to their own context and to bring any other logic or function calls outside of the context file.",
    "explanation": "Basically if movePiece is a function that operates on PiecesInPlay (a context) I had it set up like this:",
    "codeSnippet": "movePiece(newLocation) {\n// math that checks if newLocation is valid\n// updates newLocation to a valid one\n// removePieceFromBoard (which updates a different context)\n// actually move the piece\n// addPieceToBoard (which updates a different context)\n}\n\nonDragEnd {\n// Maybe more logic that also can update the location (this made things very confusing)\nmovePiece(newLocation)\n}\n\nremovePieceFromBoard and addPieceToBoard are functions in a different context file that \n just keeps track of the 2D array representing the board. But they don't actually \n do anything visually.\n\nAnd I had to change it to\n\nmovePiece(newLocation) {\n// actually move the piece in the PiecesInPlay context (which makes it move visually)\n}\n\nonDragEnd {\n// math that checks if newLocation is valid\n// updates newLocation to a valid one\n// removePieceFromBoard (which updates a different context)\nmovePiece(newLocation)\n// addPieceToBoard (which updates a different context) \n}"
  },
  {
    "id": "testing-multi-user",
    "project": "secret-santa",
    "summary": "Testing Multi-User Interactions",
    "challenge": "",
    "explanation": "",
    "codeSnippet": ""
  },
  {
    "id": "loading-sequence",
    "project": "meet-near-me",
    "summary": "Alpine Loading Sequence for Embed Widget",
    "challenge": "To create the embed widget, I used innerHTML, but innerHTML doesn't execute javascript. We have several templ files (Go templating language) with script tags in the same file. To handle this, I had to write a script to extract the script tags out, replace them with html markers, and then insert them back after the DOM has been recreated for the embed. One challenge was getting the timing right for Alpine JS because in our HTML we have things like x-data=getHomeState() but getHomeState() uses an Alpine store that is only initialized after the alpine state script runs.",
    "explanation": "I implemented a retry mechanism that checks if the stores have been registered every 50ms (up to 20 retries, 1 second total) and only initializes Alpine once all stores are confirmed to exist.",
    "codeSnippet": ""
  },
  {
    "id": "location-UX",
    "project": "meet-near-me",
    "summary": "UX for setting location temporarily or permanantly",
    "challenge": "I was creating a `Locate Me` feature that uses the browser geolocation API to locate users when they want to search for events near them, rather than selecting a city from the dropdown. I was asked to automatically update the user's permanent location in the database whenever this feature is used. Since this was just another option to update the state of the events showing (with the source of truth being the dropdown preview) I felt it would be confusing for Locate Me to have a different behavior than the rest of the dropdown.",
    "explanation": "I pushed for adding a checkbox or modal prompting the user if they want to update their default location. I really wanted the behavior for Locate Me and the rest of the dropdown to be the same but if someone was just checking out many different cities with the dropdown, they may get tired of having to click `No I don't want to update my defualt location` each time, which is honestly fair. So we settled on having a `Do you want to save this as your default city?` prompt only show when someone uses Locate Me.",
    "codeSnippet": ""
  }
]
